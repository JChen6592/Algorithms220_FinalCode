import java.util.*;

class HuffmanNode {

	int data;               
	char c;

	HuffmanNode left;               //left node
	HuffmanNode right;              //right node 
}

// comparator class helps to compare the node on the basis of one of its attributes
// Here will be compared on the basis of data values of the nodes.
class MyComparator implements Comparator<HuffmanNode> {
	public int compare(HuffmanNode x, HuffmanNode y)
	{
  	return x.data - y.data;
	}
}

public class Main
{
  // recursive function to print the
	// huffman-code through the tree traversal.
	// Here s is the huffman - code generated.
	public static void printCode(HuffmanNode root, String s)
	{

		// base case; if the left and right are null, it is leaf node, return
		// the code s generated by traversing the tree.
		if (root.left == null && root.right	== null && Character.isLetter(root.c)) {
    // c is the character in the node
			System.out.println(root.c + ":" + s);
      return;
		}

		// recursive calls for left and right sub-tree of the generated tree.
		printCode(root.left, s + "0");     // if we go to left then add "0" to the code String s.
		printCode(root.right, s + "1");    // if we go to the right add"1" to the code String s.
	}

  //where we execute program
    public static void main(String[] args)
    {
    // predefined standard input object
        System.out.println("Enter the poem: ");
        Scanner sc = new Scanner(System.in);
    //store String user input, read nextLine
        String name = sc.nextLine();
    //split the string into characters and store into String array
        String[] array1= name.split("");
    //test print out data in string array and length
      //  System.out.println(Arrays.toString(array1));
      //  System.out.println(array1.length);

    //sort in alphabetical order array1 with stored elements
     //   Arrays.sort(array1);
     //     for(int i = 0; i < array1.length; i++)
     //       System.out.println(array1[i]);

    //  Creates a string array list of characters
        List<String> charList = Arrays.asList(array1);
    //  List<String> list = Arrays.asList("B", "A", "A", "C", "B", "A"," ", "-", "A","a","b","b","b");

    //  Create an integer array list to store values of occurances of each string object
        List<Integer> freq = new ArrayList<>();

    //Create hashset of variable 'distinct', iterate through charlist string
        Set<String> distinct = new HashSet<>(charList);
        for (String s: distinct) {
          //test print character and coressponding frequency
       //     System.out.println(s + ": " + Collections.frequency(charList, s));
         //   System.out.println(distinct);
         // collect frequency of characters in charlist string list, in alphabetical order
	          freq.add(Collections.frequency(charList,s));
         //   System.out.println(Collections.frequency(list,s));
        }
        //occurance of characters test print
      //  System.out.println(freq);

        //Takes our charlist and creates a tree set, where elements are ordered based on their natural ordering
        //Set makes sure there are no duplicates 
        Set<String> set = new TreeSet<>(charList);

		    // construct a new list from set
		    List<String> noDup = new ArrayList<>(set);

        //organized list with no duplicates, test print
		  //  System.out.println(noDup);

        //System.out.println(charList);

        //Convert string list into string array. test print
        String [] charP = noDup.toArray(new String[noDup.size()]);
      //  System.out.println(Arrays.toString(charP));
        
        //create 2D char array a1 with length of previous string array length
        char[][] a1 = new char[charP.length][];

        //iterate and make char a1 array into 1D array
        for(int i =0;i<charP.length;i++){
          a1[i]=charP[i].toCharArray();
        }

        //
        int total=0;
        for(int i =0;i<charP.length;i++){
            total = total + a1[i].length;
        }
        
        char[] allchar = new char[total]; 

        // Copying the contents of the 2d array to a new 1d array
        int counter = 0;                            // Counter as the index of your allChar array
        for (int i = 0; i < a1.length; i++) { 
          for (int j = 0; j < a1[i].length; j++) { // nested for loop - typical 2d array format
            allchar[counter++] = a1[i][j];        // copying it to the new char array
          }
        }
        //test print new char array
      //  System.out.println(Arrays.toString(allchar));

        //Convert integer list into integer array, test print
        Integer [] freqChars = freq.toArray(new Integer[freq.size()]);
        //test print character frequency in array to check ordering
      //  System.out.println(Arrays.toString(freqChars));

        //PriorityQueue with parameters
        	PriorityQueue<HuffmanNode> q
			= new PriorityQueue<HuffmanNode>(allchar.length, new MyComparator());

		for (int i = 0; i < allchar.length; i++) {

			// creating a huffman node object
			// and adding it to the priority-queue.
			HuffmanNode hn = new HuffmanNode();

			hn.c = allchar[i];
			hn.data = freqChars[i];

			hn.left = null;
			hn.right = null;

			// add functions adds
			// the huffman node to the queue.
			q.add(hn);
		}

		// create a root node
		HuffmanNode root = null;

		// Here we will extract the two minimum value
		// from the heap each time until
		// its size reduces to 1, extract until
		// all the nodes are extracted.
		while (q.size() > 1) {

			// first min extract.
			HuffmanNode x = q.peek();
			q.poll();

			// second min extarct.
			HuffmanNode y = q.peek();
			q.poll();

			// new node f which is equal
			HuffmanNode f = new HuffmanNode();

			// to the sum of the frequency of the two nodes
			// assigning values to the f node.
			f.data = x.data + y.data;
			f.c = '-';

			// first extracted node as left child.
			f.left = x;

			// second extracted node as the right child.
			f.right = y;

			// marking the f node as the root node.
			root = f;

			// add this node to the priority-queue.
			q.add(f);
		}

		// print the codes by traversing the tree
		printCode(root, "");
  }
}